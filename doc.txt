简介:
      stpool是一个轻便高效的线程池/任务池库. stpool被开启后,使用者可以往stpool添加任务,
   stpool会根据当前的配置自动启动线程去执行这些任务,当stpool中没有任务时,线程会自动退出
   以避免占用过多系统资源.


应用场景:
 
        适合间歇性或者持续性的并发程度高,任务执行时间较短的应用系统(比如: 高并发服务器 
   或者实现asio),也可应用在普通的工作线程组的使用
	

特性:
 
     1. 采用c语言编写,提供丰富的API接口,提供对任务粒度的跟踪
   
     2. 对os层进行了抽象,使具有良好的跨平台的能力(支持win32,linux,unix,arm,...)
   
     3. 轻便快速, API接口自然易于使用,可直接商用
   
     4. 能随时调整和控制线程池的线程数目,内部已智能维护力求
        其占用最小的系统资源且最快速的来调度任务
     
     5. 提供优先级任务,内置内存对象池,避免内存碎片化

 模型:
                                  threadManager (线程管理器)
                                        |
         ---------------------------------------------------------------       
          workingThread0            workingThread1   ...           workingThreadn                  
              \                         |                            /
               \------------------------|---------------------------/
                                        ▲
                                        |
                                   taskScheduler (任务调度器)
                                        |
         -------------------------------▲--------------------------------
 
               pri_q[0]       pri_q[1]      .....        pri_q[10]      (任务池)
           |--------------|--------------|------------|---------------|
           | tsk9_before  | tsk14_before |   ...      | task99_before |
           | tsk9_after   | tsk10_after  |            | task99_after  | 
           | tsk7_after   | tsk9_after   |            | task90_after  |
           | tsk6_before  |              |            |   ....        |
           |  .........   |              |            |               |
           | tsk0_before  |              |            |               |
           | tsk0_after   |              |            |               |
           |--------------|--------------|------------|---------------|

   tskX_Y (X表示优先级, Y表示策略),比如 tsk9_before表示task的优先级为9，使用的是
          STPOLICY_PRI_SORT_INSERTBEFORE策略排序,见stpool.h头文件

   pri_q[x] 表示优先级队列(图示展示的为10个, 其数目可由用户在使用@stpool_create创建线程池是根据
            情况创建,每个队列将容纳100/pri_q_num个优先级的任务. (比如如果pri_q_num为1，则只有一个
            队列，所有的任务都会在该队列上按优先级排序)
   
  taskScheduler 任务调度器,从任务池中选中任务供线程池调度,本库是按照优先级来调度的，优先级越高，
            越先被调度,所以如上图中, 当pri_q[10] ~ pri_q[1]的任务全部调度完毕后,pri_q[0]中的任务
            才开始被调度，

    @stpool_add_task)/@stpool_add_pri_task往任务池中添加任务. threadManager线程池管理器
根据任务池中的任务状况和系统负载和当前任务执行情况来启动合适数量的线程池来执行任务. taskScheduler
负责从任务池中选中任务来派发给wokingThread工作线程来执行任务.


 API使用:
     1. HPOOL stpool_create(int maxthreads, int minthreads, int suspend, int pri_q_num)
         描述:
	    
             创建一个线程池, 创建后可使用@stpool_release进行销毁.
         参数:
                 [in] maxthreads 限制线程池中最大的服务线程数

                 [in] minthreads 预留的最小服务线程数. 当线程执行完任务后, 就绪队列里已经没有任何任务时,
                                 将会有minthreads数目的线程将不会退出,而是进入休眠状态等待用户往其中添加
                                 任务.其它额外的线程将会自动退出以节省系统资源. 

                 [in] suspend    是否休眠线程池. 线程池中如果进入休眠状态,所有后续添加的任务就会放到等待队列,
                                 而不会被调度.直到用户使用@stpool_resume(hp)来唤醒线程池.
   
 
                 [in] pri_q_num  优先级队列的数量. pool有100个优先级[0~99],  每个优先级队列将容纳100 / @pri_q_num
                                 个优先级的任务, 优先级越高的任务会被优先调度,任务在投递到pool时候,首先会根据优先级
                                 快速定位到要投递的队列. 
         返回值:
	     
                 成功返回线程池句柄, 失败返回NULL
  
 

   2. long stpool_addref(HPOOL hp)
         描述:
                引用计数+1, stpool可以被其它模块组件公用,在递交给其它模块前可以使用@stpool_addref来递增引用计数
              以确保线程池对象一直存在.当用户不需要使用时, 用户需要调用@stpool_release来递减其引用计数,当引用计
              数变为0时, stpool将会自动被销毁. (@stpool_create成功后其引用计数为1).
	
         参数:
                 [in]  hp   线程池句柄

         返回值:
	    
                 当前线程池的引用计数

   3. long stpool_release(HPOOL hp)
            描述:
                 引用计数-1

            参数:
                  [in]  hp   线程池句柄

          返回值:
	    
                 当前线程池的引用计数

          注意:
              此函数不会阻塞,会立刻返回,当引用计数为0时, 用户不应该再操纵HPOOL句柄, 因为引用
         计数为0时，表示句柄hp将被回收,将失效,pool会在后台被立刻销毁.
              引用计数为0时,对线程池中的任务的影响.
              1)当引用计数为0时,线程池仍处于suspended状态时,线程池内在排队的任务将会被移除
         (任务的@task_complete将会被通知).

              2)当引用计数为0时,线程池未处于suspended状态,线程池仍将会在后台执行完所有任务.只是
          线程池的句柄不再有效,即用户已不能控制线程池. 当线程池中所有的任务被完后后,线程池将
          自动被销毁. (同时这种情况下,任何任务的重新调度请求会被拒绝(即@task_complete返回非0))
          
  
   4. void stpool_set_activetimeo(HPOOL hp, long acttimeo)
            描述:
	           设置线程池中线程等待任务的休眠时间. 当线程在没有任何任务可执行时，会进入
                休眠状态,休眠一定时间后如果还没有任务唤醒它,则线程将会自动退出. 
                (休眠时间是@acttimeo + random % 60s, ,默认的@acttimeo是20s)

            参数:
	    
                  [in]  hp   线程池句柄
                    
          返回值:
                   无

   5. void stpool_adjust_abs(HPOOL hp, int maxthreads, int minthreads)
           描述:
	        调整线程池中的服务线程绝对数目. 此函数并不会阻塞. 
             (参数条件: @maxthreads >=1, @minthread >=0, @minthreads <= @maxthreads)

           参数:
                 [in]  hp         线程池句柄
                 [in] maxthreads  意义同@tpool_create参数
                 [in] minthreads  意义同@tpool_create参数
                    
          返回值:
	    
                   无

   6. void stpool_adjust(HPOOL hp, int maxthreads, int minthreads)
         此函数同@stpool_adjust_abs，其区别在于stpool_adjust传入的参数是相对参数.
         比如: 
             stpool_adjust(hp, 1, 0);  表示将线程池的最大线程数量+1, 最小数量不变
             stpool_adjust(hp, 0, -1); 表示将线程池中的最大线程数量不变，最小线程数量-1
           
 
   7. void stpool_adjust_wait(HPOOL hp)
            描述:
                   @stpool_adjust(_abs)可能会导致一些服务线程被标记为died以便通知其在服务
                完当前任务后马上退出.@stpool_adjust_wait将等待pool内所有被标记为died的线程
                全部退出后才返回.

            参数:
                 [in]  hp  线程池句柄
                    
          返回值:
	    
                无

  8. void stpool_suspend(HPOOL hp, int wait)
          描述:
                   使线程池进入睡眠, 当线程池进入睡眠后,除了当前正在被线程池调度的任务外,线程池将不在继续执行
                任务,新任务被投递到线程池后，会一直处于等待状态,当用户调用@stpool_resume唤醒线程池后,线程池会
                继续执行任务

          参数: 
                   [in]    hp     线程池句柄
                   [in]    wait   是否等待正在调度的任务被执行完.
                         
          返回值:
                  无
  
  9. void stpool_resume(HPOOL hp)
          描述:
                唤醒线程池.线程池被唤醒后将立马调度在排队等待的任务.

            参数:
                   [in]    hp   线程池句柄
                                        
          返回值:
                  无

  10. struct stpool_stat_t * stpool_getstat(HPOOL hp, struct stpool_stat_t *stat)
            描述:
	          获取线程池的状态信息
            参数:
                 [in]      hp   线程池句柄
                 [in/out] stat  待填充的状态对象
          返回值:
                 线程池的状态信息


  11. const char *stpool_status_print(HPOOL hp, char *buffer, size_t bufferlen)
            描述:
                 打印线程池的状态信息到buffer
            参数:
                 [in]    hp         线程池句柄
                 [out]   buffer     待填充的buffer,如果为NULL，则使用内置的静态buffer
                 [in]   bufferlen   buffre的长度
          返回值:
               如果buffer不为NULL,则返回buffer, 否则返回内置的静态buffer


  12. int  stpool_add_task(HPOOL hp, struct sttask_t *tsk)
           描述:
                  投递一个任务到线程池. 任务被投递到线程池后将会被线程池调度,tsk->task_run将会被执行,当
               tsk->task_run执行完毕后,如果tsk->task_complete不为NULL，则tsk->task_complete将会被调用以
               通知用户任务完成. 同时用户也可以使用stpool_wait(2)来等待任务完成.

           参数:
                   [in]    hp     线程池句柄
                   [in]    tsk    任务对象
                                        
          返回值:
                如果投递成功，则返回0，反则返回错误码(STPOOL_XX)

  13. int  stpool_add_routine(HPOOL hp, 
                          int (*task_run)(void *arg), 
                          int (*task_complete)(int done, int task_code, void *arg, struct stpriority_t *pri),
                          void *arg)
              描述:
                      投递一个执行路径到线程池. 参数@task_run将会被线程池执行,执行完后，如果参数@task_complete
                   不为NULL,则@task_complete将会被调用来通知用户@task_run已经执行完毕.

              参数:
                     [in]    hp                线程池句柄
                     [in]    task_run          需要被执行的回调
                     [in]    task_complete     完成回调通知(当被调用时,因为没有优先级(或者优先级为0), 参数@pri为NULL,
                                               但@stpool_add_pri_task2添加的任务在执行完后@pri会被填充为当前任务的优先级
                                               信息,用户可以改变, 参见附录1: @task_complete)
                                        
          返回值:
                 如果投递成功，则返回0，反则返回错误码(STPOOL_XX)

  14. int  stpool_add_pri_task(HPOOL hp, struct sttask_t *tsk, int pri, int pri_policy);
             描述:
                     功能同@stpool_add_task,只是@stpool_add_pri_task带优先级,优先级越高的任务将会优先调度. 
                (@stpool_add_task等价于@stpool_add_pri_task(hp, tsk, 0, STPOLICY_PRI_SORT_INSERTAFTER),即不进行任何排序
                 直接排队在最末尾. 更多优先级的控制参见附录1: @task_complete)

             参数:
                   [in]    hp         线程池句柄
                   [in]    tsk        任务对象
                   [in]    pri        优先级 [0~99],任务排队是按优先级排队的,优先级越高，则排在越前面.
                   [in]    pri_policy 优先级策略, 目前支持两种 
                                      STPOLICY_PRI_SORT_INSERTBEFORE (当排队队列中有多个相同优先级任务时,插到其最前面)
                                      STPOLICY_PRI_SORT_INSERTAFTER  (当排队队列中有多个相同优先级任务时,插到其最后面)
                                        
            返回值:
                如果投递成功，则返回0，反则返回错误码(STPOOL_XX)

  15. int  stpool_add_pri_routine(HPOOL hp,
	                      int (*task_run)(void *arg),
                              int (*task_complete)(long vmflags, int task_code, void *arg, struct stpriority_t *pri),
                              void *arg, int pri, int pri_policy);

             描述:
                     功能同@stpool_add_routine,只是@stpool_add_pri_routine带优先级,优先级越高的任务将会优先调度. 
                @stpool_add_routine等价于@stpool_add_pri_routine(hp, task_run, task_complete, arg, 0, STPOLICY_PRI_SORT_INSERTAFTER)
 
  16. void stpool_extract(struct sttask_t *task, void **task_run, void **task_complete, void **arg);
             描述:
                     提取任务信息. 在@tskstat_walk(参见@stpool_mark_task)或者@sttask_match(参见@stpool_waitex)中,pool给其
                 传递了任务状态参数，用户可以使用stpool_extract来提取提交任务的信息. 
            
             参数:
                   [in]   task          任务状态对象中包含的task, 见@stpool_gettskstat/@stpool_mark_task/@stpool_waitex
                   [out]  task_run      如果不为NULL,则task_run指针将被填充为@stpool_add_xx函数添加任务时的@task_run参数
                   [out]  task_complete 如果不为NULL,则task_complete指针将被填充为@stpool_add_xx函数添加任务时的@task_complete参数
                   [out]  arg           如果不为NULL,则arg指针将被填充为@stpool_add_xx函数添加任务时的@arg参数
           返回值:
                  无

  17. long stpool_gettskstat(HPOOL hp, struct stpool_tskstat_t *stat);
            描述:
                  获取任务的状态信息
            参数:
                  [in]      hp       线程池句柄
                  [in/out]  stat     任务状态对象, tsk->task需要被设置带查询的任务地址
          返回值:
                    任务的状态.
                          0             任务不存在
                    TASK_F_WAIT         处于排队等待状态
                    TASK_F_SCHEDULING   处于被调度状态(即@task_run正在被执行或即将被执行)
                    TASK_F_DISPATCHING  处于被分发状态(即@task_complete正在被执行或即将被执行)
                    TASK_F_SWAPED       处于被换出状态(这是线程池处于休眠状态,即用户调用了@stpool_suspend)

                   同时参数@stat将会被填充task的具体状态信息.


  18. int  stpool_mark_task(HPOOL hp, 
			 struct sttask_t *tsk,
                         int (*tskstat_walk)(struct stpool_tskstat_t *stat, void *arg),	
                         void *arg);
            描述:
                     标记线程池中的任务,所做的标记将会被记录在task的内置的vmflags成员中
            参数:
	    
                   [in]    hp        线程池句柄
                   [in]    tsk       需要标记的task, 如果不为NULL，则只有地址为tsk的任务才会
                                     传递给@tskstat_walk,否则所有当前存在于线程池中的任务都会
                                     传递给tskstat_walk
                   [in]    tskstat_walk 回调,用户可以在其中可以使用下面的掩码来标记任务.
                             
                                       STMASK_VMARK_REMOVE
                                             移除该任务,task_complete将由stpool_mark_task负责调用

                                       STMASK_VMARK_REMOVE_BYPOOL
 					     移除该任务,task_complete将由pool负责调用

                                       STMASK_VMARK_DISABLE_RESCHEDULE
                                             禁止任务重新执行,即在task_complete中即使返回非0值,任务也将
                                       不会自动被投递到线程池中. (当然这个时候可以使用@stpool_add_xx
                                       来显示添加到线程池是可以的),一个任务一旦被STMASK_VMARK_DISABLE_RESCHEDULE
                                       标记上，则它不能再被自动的投递到任务池中.当然用户可以显示调用stpool_add_xx
                                       函数重新投递改任务.

                                       注意: 只有在排队的任务才可以被标记为STMASK_VMARK_REMOVE或STMASK_VMARK_REMOVE_BYPOOL
                                             即如果任务状态满足 (STTASK_F_SCHEDULING|STTASK_F_DISPATCHING) & stat 则这个移除
                                             标记没有任何作用.

                                     (如果tskstat_walk返回-1,则表示停止继续访问任务, 返回0表示
                                      仅仅是访问任务，不标记任务, 其他掩码表示访问任务的时候也标记任务)

                   [in]    arg       tskstat_walk的参数
          返回值:
	    
                   传递给@tskstat_walk的task任务个数.
          

  19. int stpool_disable_rescheduling(HPOOL hp, struct sttask_t *tsk);
            描述:
                  将任务标记为STMASK_VMMASK_DISABLE_RESCHEDULE状态,即即使任务在task_complete中返回非0，该任务也不会
            成功投递到任务池中.
            
           参数:
                 [in]    hp      线程池句柄
                 [in]    tsk     待标记的任务对象,如果为NULL，则当前任务池中所有的任务都将会被标记

           返回值:
                 被标记的任务数

  20. void stpool_throttle_enable(HPOOL hp, int enable)
            描述:
	           使能线程池的瓶塞, 当瓶塞被使能时,任何都不能被添加到线程池, @stpool_add_task(2)/
                @stpool_add_pri_task(2)会返回错误码： STPOOL_ERR_THROTTLE.
                    
                   当瓶塞被使能时候,这个时候当task在task_complete返回非0时,task_complete将再次被调用,
                task_complete的参数task_code为STPOOL_ERR_THROTTLE.

            参数:
                  [in]    hp     线程池句柄
                  [in]   enalbe  1:使能线程池的瓶塞  0:移除瓶塞                           
          返回值:
	    
                 无

  21. int  stpool_throttle_disabled_wait(HPOOL hp, long ms)
             描述:
                     等待线程池的瓶塞被移除, 当瓶塞被使能时,当用户再次调用@stpool_throttle_enalbe(hp, 0)
                  时该函数才会返回.
             参数:
                   [in]    hp    线程池句柄
                   [in]    ms    等待的毫秒数.-1表示INFINITE
                                        
          返回值:
                 0则表示瓶塞被移除, 返回1则表示等待超时瓶塞还没有被移除.


  22. int  stpool_remove_pending_task(HPOOL hp, struct sttask_t *tsk, int dispatched_by_pool);
           描述:
                移除正在排队等待的任务

            参数:
                     [in]    hp                 线程池句柄
                     [in]    tsk                需要移除的任务对象, 如果tsk为NULL，则表示移除线程池中所有等待的任务,
                                                移除的任务的task_complete将会被调用,@task_code=POOL_ERR_REMOVE

                     [in]    dispatched_by_pool 如果为1,任务的task_complete将由pool调用,同时task_complete
                                                的参数@vmflags被标记上STTASK_VMARK_REMOVE_BYPOOL.否则task_complete
                                                将由stpool_remove_pending_task本身负责调用. @vmflags被标记上STTASK_VMARK_REMOVE
                                    
                                        
          返回值:
                  如果投递成功，则返回0，反则返回错误码(POOL_XX)


  23. int  stpool_wait(HPOOL hp, struct sttask_t *tsk, long ms)
            描述:
                    等待任务被完成并移出线程池. (当任务的@task_complete被执行完毕后才返回. 如果该任务的@task_complete返回
                 非0值导致该任务被再次调度的话,stpool_wait也是不会返回的,因为它并没有被移出线程池)

            参数:
                     [in]    hp     线程池句柄
                     [in]    tsk    等待的被完成的任务对象,如果为NULL,则表示等待任务池中所有的任务
                     [in]    ms     等待的毫秒数,如果为-1,则表示一直等待，直到任务被完成
                                        
          返回值:
                  任务完成并被移出线程池则返回0，返回1则表示等待超时

  24. int  stpool_waitex(HPOOL hp, int (*sttask_match)(struct stpool_tskstat_t *stat, void *arg), void *arg, long ms);
          描述:
                   功能同@stpool_wait, 只是这里使用@sttask_match来匹配一个任务. pool将会将线程池内所有的任务状态全部传递
               给@sttask_match,只要@sttask_match返回非0,则表示任务匹配，将继续等待. 当sttask_match遍历完所有的任务后全部
               返回0,则表示线程池内没有@sttask_match匹配存在的任务,此时stpool_waitex会返回.

          参数:
                     [in]    hp              线程池句柄
                     [in]    sttask_match    匹配任务的回调
                     [in]    arg             @sttask_match的参数
                     [in]    ms              等待的毫秒数,如果为-1,则表示一直等待，直到任务被完成
                                        
          返回值:
                  同stpool_wait


附录1:
    int (*task_complete)(long vmflags, int task_code, void *arg, struct stpriority_t *pri);
     
    1. 什么时候被调用?
        下列情况下的任何之一满足就会被调用.
          A. 任务的task_run被线程池执行完毕. 
             (此时@vmflags会有STTASK_VMARK_DONE标记, 同时@task_code为task_run的返回值)

          B. 任务已经被投递到线程池,但用户调用了@stpool_remove_pending_task/@stpool_mark_task对任务执行了
             移除,这个时候任务的完成回调通知task_complete将会被调用.
             (此时@vmflags会有STTASK_VMARK_REMOVE标记, 同时@task_code=STPOOL_TASK_ERR_REMOVED)

          C. task_complete返回一个非0值,vmflags没有被设置为STMASK_VMARK_DISABLE_RESCHEDULE,但在task_complete
             调用期间用户使用@stpool_mark_task标记了STPOOL_TASK_ERR_DISABLE_RESCHEDULE, 导致pool在重新投递任务
             时候检测到该任务已经禁止重新投递,然后会再次调用task_complete(@task_code=STPOOL_TASK_ERR_DISABLE_RESCHEDULE).

             即综合B,C无论怎样,pool将会保证只要设置了STMASK_VMARK_DISABLE_RESCHEDULE, task_complete里一定会获得一次而且只有一次通知.

    2. 参数stpriority_t *pri
         .当任务是被用户使用@stpool_add_pri_task/@stpool_add_pri_routine添加的时候,完成通知回调的@pri参数
     会被填充当前的task的调度优先级, 如果用户需要该任务继续执行,即在task_complete里返回非0值, 用户可以改变
     @pri里面的并在task_complete返回2，告诉pool该任务使用指定的优先级重新执行. 否则pool将会递减该任务优先级
     属性,因为其已经被执行了一次,这样防止其它低优先级任务长期处于饥饿状态.

         .@stpool_add_task/@stpool_add_routine添加的任务则该任务完成时,传给task_complete的参数@pri是NULL

    3. 关于task_complete返回非0值
       返回非0值，表示用户希望该任务继续被执行,返回2则表示使用@pri指定的优先级执行
           

    4. 提示
          在@tskstat_walk(见@stpool_mark_task)和sttask_match(见@stpool_waitex)中只允许调用@stpool_version/@stpool_extract,
      因为在回调前pool已经上了锁. 其它API访问pool会导致获取不到锁.

 附录2:
     (Email: piggy_xrh@163.com   QQ: 1169732280)

 附录3:
    demo.c       综合测试demo
    demo_sche.c  测试任务池调度demo
    demo_pri.c   测试优先级demo